C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE UIP
OBJECT MODULE PLACED IN .\out\uip.obj
COMPILER INVOKED BY: D:\Program Files\keil\C51\BIN\C51.EXE uip\uip.c BROWSE INCDIR(.\app;.\bsp;.\uip) DEBUG OBJECTEXTEND
                    - PRINT(.\out\uip.lst) OBJECT(.\out\uip.obj)

line level    source

   1          /**
   2           * \addtogroup uip
   3           * @{
   4           */
   5          
   6          /**
   7           * \file
   8           * The uIP TCP/IP stack code.
   9           * \author Adam Dunkels <adam@dunkels.com>
  10           */
  11          
  12          /*
  13           * Copyright (c) 2001-2003, Adam Dunkels.
  14           * All rights reserved. 
  15           *
  16           * Redistribution and use in source and binary forms, with or without 
  17           * modification, are permitted provided that the following conditions 
  18           * are met: 
  19           * 1. Redistributions of source code must retain the above copyright 
  20           *    notice, this list of conditions and the following disclaimer. 
  21           * 2. Redistributions in binary form must reproduce the above copyright 
  22           *    notice, this list of conditions and the following disclaimer in the 
  23           *    documentation and/or other materials provided with the distribution. 
  24           * 3. The name of the author may not be used to endorse or promote
  25           *    products derived from this software without specific prior
  26           *    written permission.  
  27           *
  28           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
  29           * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  30           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  31           * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
  32           * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  34           * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  35           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  36           * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  37           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  38           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
  39           *
  40           * This file is part of the uIP TCP/IP stack.
  41           *
  42           * $Id: uip.c,v 1.62.2.10 2003/10/07 13:23:01 adam Exp $
  43           *
  44           */
  45          
  46          /*
  47          This is a small implementation of the IP and TCP protocols (as well as
  48          some basic ICMP stuff). The implementation couples the IP, TCP and the
  49          application layers very tightly. To keep the size of the compiled code
  50          down, this code also features heavy usage of the goto statement.
  51          
  52          The principle is that we have a small buffer, called the uip_buf, in
  53          which the device driver puts an incoming packet. The TCP/IP stack
  54          parses the headers in the packet, and calls upon the application. If
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 2   

  55          the remote host has sent data to the application, this data is present
  56          in the uip_buf and the application read the data from there. It is up
  57          to the application to put this data into a byte stream if needed. The
  58          application will not be fed with data that is out of sequence.
  59          
  60          If the application whishes to send data to the peer, it should put its
  61          data into the uip_buf, 40 bytes from the start of the buffer. The
  62          TCP/IP stack will calculate the checksums, and fill in the necessary
  63          header fields and finally send the packet back to the peer.
  64          */
  65          
  66          
  67          #include "uip.h"
  68          #include "uipopt.h"
  69          #include "uip_arch.h"
  70          
  71          #include "app.h"
  72          
  73          
  74          /*-----------------------------------------------------------------------------------*/
  75          /* Variable definitions. */
  76          
  77          
  78          /* The IP address of this host. If it is defined to be fixed (by setting UIP_FIXEDADDR 
  79          to 1 in uipopt.h), the address is set here. Otherwise, the address */
  80          #if UIP_FIXEDADDR > 0
  81          const u16_t code uip_hostaddr[2] =
  82            {HTONS((UIP_IPADDR0 << 8) | UIP_IPADDR1),
  83             HTONS((UIP_IPADDR2 << 8) | UIP_IPADDR3)};
  84          const u16_t code uip_arp_draddr[2] =
  85            {HTONS((UIP_DRIPADDR0 << 8) | UIP_DRIPADDR1),
  86             HTONS((UIP_DRIPADDR2 << 8) | UIP_DRIPADDR3)};
  87          const u16_t code uip_arp_netmask[2] =
  88            {HTONS((UIP_NETMASK0 << 8) | UIP_NETMASK1),
  89             HTONS((UIP_NETMASK2 << 8) | UIP_NETMASK3)};
  90          #else
              u16_t idata uip_hostaddr[2];       
              u16_t idata uip_arp_draddr[2], uip_arp_netmask[2];
              #endif /* UIP_FIXEDADDR */
  94          
  95          
  96          u8_t xdata uip_buf[UIP_BUFSIZE+2];   /* The packet buffer that contains
  97                                          incoming packets. */
  98          volatile u8_t *uip_appdata;  /* The uip_appdata pointer points to
  99                                          application data. */
 100          volatile u8_t *uip_sappdata;  /* The uip_appdata pointer points to the
 101                                           application data which is to be sent. */
 102          #if UIP_URGDATA > 0
 103          volatile u8_t *uip_urgdata;  /* The uip_urgdata pointer points to
 104                                          urgent data (out-of-band data), if
 105                                          present. */
 106          volatile u8_t idata uip_urglen, uip_surglen;
 107          #endif /* UIP_URGDATA > 0 */
 108          
 109          volatile u16_t idata uip_len, uip_slen;
 110                                       /* The uip_len is either 8 or 16 bits,
 111                                          depending on the maximum packet
 112                                          size. */
 113          
 114          volatile u8_t idata uip_flags;     /* The uip_flags variable is used for
 115                                          communication between the TCP/IP stack
 116                                          and the application program. */
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 3   

 117          struct uip_conn xdata *uip_conn;   /* uip_conn always points to the current
 118                                          connection. */
 119          
 120          struct uip_conn xdata uip_conns[UIP_CONNS];
 121                                       /* The uip_conns array holds all TCP
 122                                          connections. */
 123          u16_t idata uip_listenports[UIP_LISTENPORTS];
 124                                       /* The uip_listenports list all currently
 125                                          listning ports. */
 126          #if UIP_UDP
              struct uip_udp_conn idata *uip_udp_conn;
              struct uip_udp_conn idata uip_udp_conns[UIP_UDP_CONNS];
              #endif /* UIP_UDP */
 130          
 131          
 132          static u16_t idata ipid;           /* Ths ipid variable is an increasing
 133                                          number that is used for the IP ID
 134                                          field. */
 135          
 136          static u8_t idata iss[4];          /* The iss variable is used for the TCP
 137                                          initial sequence number. */
 138          
 139          #if UIP_ACTIVE_OPEN
 140          static u16_t idata lastport;       /* Keeps track of the last port used for
 141                                          a new connection. */
 142          #endif /* UIP_ACTIVE_OPEN */
 143          
 144          /* Temporary variables. */
 145          volatile u8_t uip_acc32[4];
 146          static u8_t idata c, opt;
 147          static u16_t idata tmp16;
 148          
 149          /* Structures and definitions. */
 150          #define TCP_FIN 0x01
 151          #define TCP_SYN 0x02
 152          #define TCP_RST 0x04
 153          #define TCP_PSH 0x08
 154          #define TCP_ACK 0x10
 155          #define TCP_URG 0x20
 156          #define TCP_CTL 0x3f
 157          
 158          #define ICMP_ECHO_REPLY 0
 159          #define ICMP_ECHO       8     
 160          
 161          /* Macros. */
 162          #define BUF ((uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])
 163          #define FBUF ((uip_tcpip_hdr *)&uip_reassbuf[0])
 164          #define ICMPBUF ((uip_icmpip_hdr *)&uip_buf[UIP_LLH_LEN])
 165          #define UDPBUF ((uip_udpip_hdr *)&uip_buf[UIP_LLH_LEN])
 166          
 167          #if UIP_STATISTICS == 1
              struct uip_stats uip_stat;
              #define UIP_STAT(s) s
              #else
 171          #define UIP_STAT(s)
 172          #endif /* UIP_STATISTICS == 1 */
 173          
 174          #if UIP_LOGGING == 1
              #include <stdio.h>
              void uip_log(char *msg);
              #define UIP_LOG(m) uip_log(m)
              #else
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 4   

 179          #define UIP_LOG(m)
 180          #endif /* UIP_LOGGING == 1 */
 181          
 182          /*-----------------------------------------------------------------------------------*/
 183          void
 184          uip_init(void)
 185          {
 186   1        for(c = 0; c < UIP_LISTENPORTS; ++c) {
 187   2          uip_listenports[c] = 0;
 188   2        }
 189   1        for(c = 0; c < UIP_CONNS; ++c) {
 190   2          uip_conns[c].tcpstateflags = CLOSED;
 191   2        }
 192   1      #if UIP_ACTIVE_OPEN
 193   1        lastport = 1024;
 194   1      #endif /* UIP_ACTIVE_OPEN */
 195   1      
 196   1      #if UIP_UDP
                for(c = 0; c < UIP_UDP_CONNS; ++c) {
                  uip_udp_conns[c].lport = 0;
                }
              #endif /* UIP_UDP */
 201   1        
 202   1      
 203   1        /* IPv4 initialization. */
 204   1      #if UIP_FIXEDADDR == 0
                uip_hostaddr[0] = uip_hostaddr[1] = 0;
              #endif /* UIP_FIXEDADDR */
 207   1      
 208   1      }
 209          /*-----------------------------------------------------------------------------------*/
 210          #if UIP_ACTIVE_OPEN
 211          struct uip_conn *
 212          uip_connect(u16_t *ripaddr, u16_t rport)
 213          {
 214   1        register struct uip_conn *conn, *cconn;
 215   1        
 216   1        /* Find an unused local port. */
 217   1       again:
 218   1        ++lastport;
 219   1      
 220   1        if(lastport >= 32000) {
 221   2          lastport = 4096;
 222   2        }
 223   1      
 224   1        /* Check if this port is already in use, and if so try to find
 225   1           another one. */
 226   1        for(c = 0; c < UIP_CONNS; ++c) {
 227   2          conn = &uip_conns[c];
 228   2          if(conn->tcpstateflags != CLOSED &&
 229   2             conn->lport == htons(lastport)) {
 230   3            goto again;
 231   3          }
 232   2        }
 233   1      
 234   1      
 235   1        conn = 0;
 236   1        for(c = 0; c < UIP_CONNS; ++c) {
 237   2          cconn = &uip_conns[c]; 
 238   2          if(cconn->tcpstateflags == CLOSED) {
 239   3            conn = cconn;
 240   3            break;
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 5   

 241   3          }
 242   2          if(cconn->tcpstateflags == TIME_WAIT) {
 243   3            if(conn == 0 ||
 244   3               cconn->timer > uip_conn->timer) {
 245   4              conn = cconn;
 246   4            }
 247   3          }
 248   2        }
 249   1      
 250   1        if(conn == 0) {
 251   2          return 0;
 252   2        }
 253   1        
 254   1        conn->tcpstateflags = SYN_SENT;
 255   1      
 256   1        conn->snd_nxt[0] = iss[0];
 257   1        conn->snd_nxt[1] = iss[1];
 258   1        conn->snd_nxt[2] = iss[2];
 259   1        conn->snd_nxt[3] = iss[3];
 260   1      
 261   1        conn->initialmss = conn->mss = UIP_TCP_MSS;
 262   1        
 263   1        conn->len = 1;   /* TCP length of the SYN is one. */
 264   1        conn->nrtx = 0;
 265   1        conn->timer = 1; /* Send the SYN next time around. */
 266   1        conn->rto = UIP_RTO;
 267   1        conn->sa = 0;
 268   1        conn->sv = 16;
 269   1        conn->lport = htons(lastport);
 270   1        conn->rport = rport;
 271   1        conn->ripaddr[0] = ripaddr[0];
 272   1        conn->ripaddr[1] = ripaddr[1];
 273   1        
 274   1        return conn;
 275   1      }
 276          #endif /* UIP_ACTIVE_OPEN */
 277          /*-----------------------------------------------------------------------------------*/
 278          #if UIP_UDP
              struct uip_udp_conn *
              uip_udp_new(u16_t *ripaddr, u16_t rport)
              {
                register struct uip_udp_conn *conn;
                
                /* Find an unused local port. */
               again:
                ++lastport;
              
                if(lastport >= 32000) {
                  lastport = 4096;
                }
                
                for(c = 0; c < UIP_UDP_CONNS; ++c) {
                  if(uip_udp_conns[c].lport == lastport) {
                    goto again;
                  }
                }
              
              
                conn = 0;
                for(c = 0; c < UIP_UDP_CONNS; ++c) {
                  if(uip_udp_conns[c].lport == 0) {
                    conn = &uip_udp_conns[c]; 
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 6   

                    break;
                  }
                }
              
                if(conn == 0) {
                  return 0;
                }
                
                conn->lport = HTONS(lastport);
                conn->rport = HTONS(rport);
                conn->ripaddr[0] = ripaddr[0];
                conn->ripaddr[1] = ripaddr[1];
                
                return conn;
              }
              #endif /* UIP_UDP */
 319          /*-----------------------------------------------------------------------------------*/
 320          /*
 321          void
 322          uip_unlisten(u16_t port)
 323          {
 324            for(c = 0; c < UIP_LISTENPORTS; ++c) {
 325              if(uip_listenports[c] == port) {
 326                uip_listenports[c] = 0;
 327                return;
 328              }
 329            }
 330          }       */
 331          /*-----------------------------------------------------------------------------------*/
 332          void
 333          uip_listen(u16_t port)
 334          {
 335   1        for(c = 0; c < UIP_LISTENPORTS; ++c) {
 336   2          if(uip_listenports[c] == 0) {
 337   3            uip_listenports[c] = port;
 338   3            return;
 339   3          }
 340   2        }
 341   1      }
 342          /*-----------------------------------------------------------------------------------*/
 343          /* XXX: IP fragment reassembly: not well-tested. */
 344          
 345          #if UIP_REASSEMBLY
              #define UIP_REASS_BUFSIZE (UIP_BUFSIZE - UIP_LLH_LEN)
              static u8_t uip_reassbuf[UIP_REASS_BUFSIZE];
              static u8_t uip_reassbitmap[UIP_REASS_BUFSIZE / (8 * 8)];
              static const u8_t code bitmap_bits[8] = {0xff, 0x7f, 0x3f, 0x1f,
                                                  0x0f, 0x07, 0x03, 0x01};
              static u16_t uip_reasslen;
              static u8_t uip_reassflags;
              #define UIP_REASS_FLAG_LASTFRAG 0x01
              static u8_t uip_reasstmr;
              
              #define IP_HLEN 20
              #define IP_MF   0x20
              
              static u8_t
              uip_reass(void)
              {
                u16_t offset, len;
                u16_t i;
              
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 7   

                /* If ip_reasstmr is zero, no packet is present in the buffer, so we
                   write the IP header of the fragment into the reassembly
                   buffer. The timer is updated with the maximum age. */
                if(uip_reasstmr == 0) {
                  memcpy(uip_reassbuf, &BUF->vhl, IP_HLEN);
                  uip_reasstmr = UIP_REASS_MAXAGE;
                  uip_reassflags = 0;
                  /* Clear the bitmap. */
                  memset(uip_reassbitmap, sizeof(uip_reassbitmap), 0);
                }
              
                /* Check if the incoming fragment matches the one currently present
                   in the reasembly buffer. If so, we proceed with copying the
                   fragment into the buffer. */
                if(BUF->srcipaddr[0] == FBUF->srcipaddr[0] &&
                   BUF->srcipaddr[1] == FBUF->srcipaddr[1] &&
                   BUF->destipaddr[0] == FBUF->destipaddr[0] &&
                   BUF->destipaddr[1] == FBUF->destipaddr[1] &&
                   BUF->ipid[0] == FBUF->ipid[0] &&
                   BUF->ipid[1] == FBUF->ipid[1]) {
              
                  len = (BUF->len[0] << 8) + BUF->len[1] - (BUF->vhl & 0x0f) * 4;
                  offset = (((BUF->ipoffset[0] & 0x3f) << 8) + BUF->ipoffset[1]) * 8;
              
                  /* If the offset or the offset + fragment length overflows the
                     reassembly buffer, we discard the entire packet. */
                  if(offset > UIP_REASS_BUFSIZE ||
                     offset + len > UIP_REASS_BUFSIZE) {
                    uip_reasstmr = 0;
                    goto nullreturn;
                  }
              
                  /* Copy the fragment into the reassembly buffer, at the right
                     offset. */
                  memcpy(&uip_reassbuf[IP_HLEN + offset],
                         (char *)BUF + (int)((BUF->vhl & 0x0f) * 4),
                         len);
                    
                  /* Update the bitmap. */
                  if(offset / (8 * 8) == (offset + len) / (8 * 8)) {
                    /* If the two endpoints are in the same byte, we only update
                       that byte. */
                           
                    uip_reassbitmap[offset / (8 * 8)] |=
                           bitmap_bits[(offset / 8 ) & 7] &
                           ~bitmap_bits[((offset + len) / 8 ) & 7];
                  } else {
                    /* If the two endpoints are in different bytes, we update the
                       bytes in the endpoints and fill the stuff inbetween with
                       0xff. */
                    uip_reassbitmap[offset / (8 * 8)] |=
                      bitmap_bits[(offset / 8 ) & 7];
                    for(i = 1 + offset / (8 * 8); i < (offset + len) / (8 * 8); ++i) {
                      uip_reassbitmap[i] = 0xff;
                    }      
                    uip_reassbitmap[(offset + len) / (8 * 8)] |=
                      ~bitmap_bits[((offset + len) / 8 ) & 7];
                  }
                  
                  /* If this fragment has the More Fragments flag set to zero, we
                     know that this is the last fragment, so we can calculate the
                     size of the entire packet. We also set the
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 8   

                     IP_REASS_FLAG_LASTFRAG flag to indicate that we have received
                     the final fragment. */
              
                  if((BUF->ipoffset[0] & IP_MF) == 0) {
                    uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
                    uip_reasslen = offset + len;
                  }
                  
                  /* Finally, we check if we have a full packet in the buffer. We do
                     this by checking if we have the last fragment and if all bits
                     in the bitmap are set. */
                  if(uip_reassflags & UIP_REASS_FLAG_LASTFRAG) {
                    /* Check all bytes up to and including all but the last byte in
                       the bitmap. */
                    for(i = 0; i < uip_reasslen / (8 * 8) - 1; ++i) {
                      if(uip_reassbitmap[i] != 0xff) {
                        goto nullreturn;
                      }
                    }
                    /* Check the last byte in the bitmap. It should contain just the
                       right amount of bits. */
                    if(uip_reassbitmap[uip_reasslen / (8 * 8)] !=
                       (u8_t)~bitmap_bits[uip_reasslen / 8 & 7]) {
                      goto nullreturn;
                    }
              
                    /* If we have come this far, we have a full packet in the
                       buffer, so we allocate a pbuf and copy the packet into it. We
                       also reset the timer. */
                    uip_reasstmr = 0;
                    memcpy(BUF, FBUF, uip_reasslen);
              
                    /* Pretend to be a "normal" (i.e., not fragmented) IP packet
                       from now on. */
                    BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
                    BUF->len[0] = uip_reasslen >> 8;
                    BUF->len[1] = uip_reasslen & 0xff;
                    BUF->ipchksum = 0;
                    BUF->ipchksum = ~(uip_ipchksum());
              
                    return uip_reasslen;
                  }
                }
              
               nullreturn:
                return 0;
              }
              #endif /* UIP_REASSEMBL */
 475          /*-----------------------------------------------------------------------------------*/
 476          static void
 477          uip_add_rcv_nxt(u16_t n)
 478          {
 479   1        uip_add32(uip_conn->rcv_nxt, n);
 480   1        uip_conn->rcv_nxt[0] = uip_acc32[0];
 481   1        uip_conn->rcv_nxt[1] = uip_acc32[1];
 482   1        uip_conn->rcv_nxt[2] = uip_acc32[2];
 483   1        uip_conn->rcv_nxt[3] = uip_acc32[3];
 484   1      }
 485          /*-----------------------------------------------------------------------------------*/
 486          void
 487          uip_process(u8_t flag)
 488          {
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 9   

 489   1        register struct uip_conn *uip_connr = uip_conn;
 490   1        
 491   1        uip_appdata = &uip_buf[40 + UIP_LLH_LEN];
 492   1      
 493   1        
 494   1        /* Check if we were invoked because of the perodic timer fireing. */
 495   1        if(flag == UIP_TIMER) {
 496   2      #if UIP_REASSEMBLY
                  if(uip_reasstmr != 0) {
                    --uip_reasstmr;
                  }
              #endif /* UIP_REASSEMBLY */
 501   2          /* Increase the initial sequence number. */
 502   2          if(++iss[3] == 0) {
 503   3            if(++iss[2] == 0) {
 504   4              if(++iss[1] == 0) {
 505   5                ++iss[0];
 506   5              }
 507   4            }
 508   3          }    
 509   2          uip_len = 0;
 510   2          if(uip_connr->tcpstateflags == TIME_WAIT ||
 511   2             uip_connr->tcpstateflags == FIN_WAIT_2) {
 512   3            ++(uip_connr->timer);
 513   3            if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
 514   4              uip_connr->tcpstateflags = CLOSED;
 515   4            }
 516   3          } else if(uip_connr->tcpstateflags != CLOSED) {
 517   3            /* If the connection has outstanding data, we increase the
 518   3               connection's timer and see if it has reached the RTO value
 519   3               in which case we retransmit. */
 520   3            if(uip_outstanding(uip_connr)) {
 521   4              if(uip_connr->timer-- == 0) {
 522   5                if(uip_connr->nrtx == UIP_MAXRTX ||
 523   5                   ((uip_connr->tcpstateflags == SYN_SENT ||
 524   5                     uip_connr->tcpstateflags == SYN_RCVD) &&
 525   5                    uip_connr->nrtx == UIP_MAXSYNRTX)) {
 526   6                  uip_connr->tcpstateflags = CLOSED;
 527   6      
 528   6                  /* We call UIP_APPCALL() with uip_flags set to
 529   6                     UIP_TIMEDOUT to inform the application that the
 530   6                     connection has timed out. */
 531   6                  uip_flags = UIP_TIMEDOUT;
 532   6                  UIP_APPCALL();
 533   6      
 534   6                  /* We also send a reset packet to the remote host. */
 535   6                  BUF->flags = TCP_RST | TCP_ACK;
 536   6      
 537   6      
 538   6                  goto tcp_send_nodata;
 539   6                }
 540   5      
 541   5                /* Exponential backoff. */
 542   5                uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
 543   5                                               4:
 544   5                                               uip_connr->nrtx);
 545   5                ++(uip_connr->nrtx);
 546   5                
 547   5                /* Ok, so we need to retransmit. We do this differently
 548   5                   depending on which state we are in. In ESTABLISHED, we
 549   5                   call upon the application so that it may prepare the
 550   5                   data for the retransmit. In SYN_RCVD, we resend the
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 10  

 551   5                   SYNACK that we sent earlier and in LAST_ACK we have to
 552   5                   retransmit our FINACK. */
 553   5                UIP_STAT(++uip_stat.tcp.rexmit);
 554   5                switch(uip_connr->tcpstateflags & TS_MASK) {
 555   6                case SYN_RCVD:
 556   6                  /* In the SYN_RCVD state, we should retransmit our
 557   6                     SYNACK. */
 558   6                  goto tcp_send_synack;
 559   6                  
 560   6      #if UIP_ACTIVE_OPEN
 561   6                case SYN_SENT:
 562   6                  /* In the SYN_SENT state, we retransmit out SYN. */
 563   6                  BUF->flags = 0;
 564   6                  goto tcp_send_syn;
 565   6      #endif /* UIP_ACTIVE_OPEN */
 566   6                  
 567   6                case ESTABLISHED:
 568   6                  /* In the ESTABLISHED state, we call upon the application
 569   6                     to do the actual retransmit after which we jump into
 570   6                     the code for sending out the packet (the apprexmit
 571   6                     label). */
 572   6                  uip_len = 0;
 573   6                  uip_slen = 0;
 574   6                  uip_flags = UIP_REXMIT;
 575   6                  UIP_APPCALL();
 576   6                  goto apprexmit;
 577   6                  
 578   6                case FIN_WAIT_1:
 579   6                case CLOSING:
 580   6                case LAST_ACK:
 581   6                  /* In all these states we should retransmit a FINACK. */
 582   6                  goto tcp_send_finack;
 583   6                  
 584   6                }
 585   5              }
 586   4            } else if((uip_connr->tcpstateflags & TS_MASK) == ESTABLISHED) {
 587   4              /* If there was no need for a retransmission, we poll the
 588   4                 application for new data. */
 589   4              uip_len = 0;
 590   4              uip_slen = 0;
 591   4              uip_flags = UIP_POLL;
 592   4              UIP_APPCALL();
 593   4              goto appsend;
 594   4            }
 595   3          }
 596   2          goto drop;
 597   2        }
 598   1      #if UIP_UDP 
                if(flag == UIP_UDP_TIMER) {
                  if(uip_udp_conn->lport != 0) {
                    uip_appdata = &uip_buf[UIP_LLH_LEN + 28];
                    uip_len = uip_slen = 0;
                    uip_flags = UIP_POLL;
                    UIP_UDP_APPCALL();
                    goto udp_send;
                  } else {
                    goto drop;
                  }
                }
              #endif
 611   1      
 612   1        /* This is where the input processing starts. */
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 11  

 613   1        UIP_STAT(++uip_stat.ip.recv);
 614   1      
 615   1      
 616   1        /* Start of IPv4 input header processing code. */
 617   1        
 618   1        /* Check validity of the IP header. */  
 619   1        if(BUF->vhl != 0x45)  { /* IP version and header length. */
 620   2          UIP_STAT(++uip_stat.ip.drop);
 621   2          UIP_STAT(++uip_stat.ip.vhlerr);
 622   2          UIP_LOG("ip: invalid version or header length.");
 623   2          goto drop;
 624   2        }
 625   1        
 626   1        /* Check the size of the packet. If the size reported to us in
 627   1           uip_len doesn't match the size reported in the IP header, there
 628   1           has been a transmission error and we drop the packet. */
 629   1        
 630   1        if(BUF->len[0] != (uip_len >> 8)) { /* IP length, high byte. */
 631   2          uip_len = (uip_len & 0xff) | (BUF->len[0] << 8);
 632   2        }
 633   1        if(BUF->len[1] != (uip_len & 0xff)) { /* IP length, low byte. */
 634   2          uip_len = (uip_len & 0xff00) | BUF->len[1];
 635   2        }
 636   1      
 637   1        /* Check the fragment flag. */
 638   1        if((BUF->ipoffset[0] & 0x3f) != 0 ||
 639   1           BUF->ipoffset[1] != 0) { 
 640   2      #if UIP_REASSEMBLY
                  uip_len = uip_reass();
                  if(uip_len == 0) {
                    goto drop;
                  }
              #else
 646   2          UIP_STAT(++uip_stat.ip.drop);
 647   2          UIP_STAT(++uip_stat.ip.fragerr);
 648   2          UIP_LOG("ip: fragment dropped.");    
 649   2          goto drop;
 650   2      #endif /* UIP_REASSEMBLY */
 651   2        }
 652   1      
 653   1        /* If we are configured to use ping IP address configuration and
 654   1           hasn't been assigned an IP address yet, we accept all ICMP
 655   1           packets. */
 656   1      #if UIP_PINGADDRCONF
                if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
                  if(BUF->proto == UIP_PROTO_ICMP) {
                    UIP_LOG("ip: possible ping config packet received.");
                    goto icmp_input;
                  } else {
                    UIP_LOG("ip: packet dropped since no address assigned.");
                    goto drop;
                  }
                }
              #endif /* UIP_PINGADDRCONF */
 667   1        
 668   1        /* Check if the packet is destined for our IP address. */  
 669   1        if(BUF->destipaddr[0] != uip_hostaddr[0]) {
 670   2          UIP_STAT(++uip_stat.ip.drop);
 671   2          UIP_LOG("ip: packet not for us.");        
 672   2          goto drop;
 673   2        }
 674   1        if(BUF->destipaddr[1] != uip_hostaddr[1]) {
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 12  

 675   2          UIP_STAT(++uip_stat.ip.drop);
 676   2          UIP_LOG("ip: packet not for us.");        
 677   2          goto drop;
 678   2        }
 679   1      
 680   1        if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
 681   2                                          checksum. */
 682   2          UIP_STAT(++uip_stat.ip.drop);
 683   2          UIP_STAT(++uip_stat.ip.chkerr);
 684   2          UIP_LOG("ip: bad checksum.");    
 685   2          goto drop;
 686   2        }
 687   1      
 688   1        if(BUF->proto == UIP_PROTO_TCP)  /* Check for TCP packet. If so, jump
 689   1                                           to the tcp_input label. */
 690   1          goto tcp_input;
 691   1      
 692   1      #if UIP_UDP
                if(BUF->proto == UIP_PROTO_UDP)
                  goto udp_input;
              #endif /* UIP_UDP */
 696   1      
 697   1        if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
 698   2                                              here. */
 699   2          UIP_STAT(++uip_stat.ip.drop);
 700   2          UIP_STAT(++uip_stat.ip.protoerr);
 701   2          UIP_LOG("ip: neither tcp nor icmp.");        
 702   2          goto drop;
 703   2        }
 704   1        
 705   1       icmp_input:
 706   1        UIP_STAT(++uip_stat.icmp.recv);
 707   1        
 708   1        /* ICMP echo (i.e., ping) processing. This is simple, we only change
 709   1           the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
 710   1           checksum before we return the packet. */
 711   1        if(ICMPBUF->type != ICMP_ECHO) {
 712   2          UIP_STAT(++uip_stat.icmp.drop);
 713   2          UIP_STAT(++uip_stat.icmp.typeerr);
 714   2          UIP_LOG("icmp: not icmp echo.");
 715   2          goto drop;
 716   2        }
 717   1      
 718   1        /* If we are configured to use ping IP address assignment, we use
 719   1           the destination IP address of this ping packet and assign it to
 720   1           ourself. */
 721   1      #if UIP_PINGADDRCONF
                if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
                  uip_hostaddr[0] = BUF->destipaddr[0];
                  uip_hostaddr[1] = BUF->destipaddr[1];
                }
              #endif /* UIP_PINGADDRCONF */  
 727   1        
 728   1        ICMPBUF->type = ICMP_ECHO_REPLY;
 729   1        
 730   1        if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
 731   2          ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
 732   2        } else {
 733   2          ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
 734   2        }
 735   1        
 736   1        /* Swap IP addresses. */
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 13  

 737   1        tmp16 = BUF->destipaddr[0];
 738   1        BUF->destipaddr[0] = BUF->srcipaddr[0];
 739   1        BUF->srcipaddr[0] = tmp16;
 740   1        tmp16 = BUF->destipaddr[1];
 741   1        BUF->destipaddr[1] = BUF->srcipaddr[1];
 742   1        BUF->srcipaddr[1] = tmp16;
 743   1      
 744   1        UIP_STAT(++uip_stat.icmp.sent);
 745   1        goto send;
 746   1      
 747   1        /* End of IPv4 input header processing code. */
 748   1        
 749   1      
 750   1      #if UIP_UDP
                /* UDP input processing. */
               udp_input:
                /* UDP processing is really just a hack. We don't do anything to the
                   UDP/IP headers, but let the UDP application do all the hard
                   work. If the application sets uip_slen, it has a packet to
                   send. */
              #if UIP_UDP_CHECKSUMS
                if(uip_udpchksum() != 0xffff) { 
                  UIP_STAT(++uip_stat.udp.drop);
                  UIP_STAT(++uip_stat.udp.chkerr);
                  UIP_LOG("udp: bad checksum.");    
                  goto drop;
                }  
              #endif /* UIP_UDP_CHECKSUMS */
              
                /* Demultiplex this UDP packet between the UDP "connections". */
                for(uip_udp_conn = &uip_udp_conns[0];
                    uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
                    ++uip_udp_conn) {
                  if(uip_udp_conn->lport != 0 &&
                     UDPBUF->destport == uip_udp_conn->lport &&
                     (uip_udp_conn->rport == 0 ||
                      UDPBUF->srcport == uip_udp_conn->rport) &&
                     BUF->srcipaddr[0] == uip_udp_conn->ripaddr[0] &&
                     BUF->srcipaddr[1] == uip_udp_conn->ripaddr[1]) {
                    goto udp_found; 
                  }
                }
                goto drop;
                
               udp_found:
                uip_len = uip_len - 28;
                uip_appdata = &uip_buf[UIP_LLH_LEN + 28];
                uip_flags = UIP_NEWDATA;
                uip_slen = 0;
                UIP_UDP_APPCALL();
               udp_send:
                if(uip_slen == 0) {
                  goto drop;      
                }
                uip_len = uip_slen + 28;
              
                BUF->len[0] = (uip_len >> 8);
                BUF->len[1] = (uip_len & 0xff);
                
                BUF->proto = UIP_PROTO_UDP;
              
                UDPBUF->udplen = HTONS(uip_slen + 8);
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 14  

                UDPBUF->udpchksum = 0;
              #if UIP_UDP_CHECKSUMS 
                /* Calculate UDP checksum. */
                UDPBUF->udpchksum = ~(uip_udpchksum());
                if(UDPBUF->udpchksum == 0) {
                  UDPBUF->udpchksum = 0xffff;
                }
              #endif /* UIP_UDP_CHECKSUMS */
              
                BUF->srcport  = uip_udp_conn->lport;
                BUF->destport = uip_udp_conn->rport;
              
                BUF->srcipaddr[0] = uip_hostaddr[0];
                BUF->srcipaddr[1] = uip_hostaddr[1];
                BUF->destipaddr[0] = uip_udp_conn->ripaddr[0];
                BUF->destipaddr[1] = uip_udp_conn->ripaddr[1];
               
                uip_appdata = &uip_buf[UIP_LLH_LEN + 40];
                goto ip_send_nolen;
              #endif /* UIP_UDP */
 819   1        
 820   1        /* TCP input processing. */  
 821   1       tcp_input:
 822   1        UIP_STAT(++uip_stat.tcp.recv);
 823   1      
 824   1        /* Start of TCP input header processing code. */
 825   1        
 826   1        if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
 827   2                                             checksum. */
 828   2          UIP_STAT(++uip_stat.tcp.drop);
 829   2          UIP_STAT(++uip_stat.tcp.chkerr);
 830   2          UIP_LOG("tcp: bad checksum.");    
 831   2          goto drop;
 832   2        }
 833   1        
 834   1        /* Demultiplex this segment. */
 835   1        /* First check any active connections. */
 836   1        for(uip_connr = &uip_conns[0]; uip_connr < &uip_conns[UIP_CONNS]; ++uip_connr) {
 837   2          if(uip_connr->tcpstateflags != CLOSED &&
 838   2             BUF->destport == uip_connr->lport &&
 839   2             BUF->srcport == uip_connr->rport &&
 840   2             BUF->srcipaddr[0] == uip_connr->ripaddr[0] &&
 841   2             BUF->srcipaddr[1] == uip_connr->ripaddr[1]) {
 842   3            goto found;    
 843   3          }
 844   2        }
 845   1      
 846   1        /* If we didn't find and active connection that expected the packet,
 847   1           either this packet is an old duplicate, or this is a SYN packet
 848   1           destined for a connection in LISTEN. If the SYN flag isn't set,
 849   1           it is an old packet and we send a RST. */
 850   1        if((BUF->flags & TCP_CTL) != TCP_SYN)
 851   1          goto reset;
 852   1        
 853   1        tmp16 = BUF->destport;
 854   1        /* Next, check listening connections. */  
 855   1        for(c = 0; c < UIP_LISTENPORTS; ++c) {
 856   2          if(tmp16 == uip_listenports[c])
 857   2            goto found_listen;
 858   2        }
 859   1        
 860   1        /* No matching connection found, so we send a RST packet. */
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 15  

 861   1        UIP_STAT(++uip_stat.tcp.synrst);
 862   1       reset:
 863   1      
 864   1        /* We do not send resets in response to resets. */
 865   1        if(BUF->flags & TCP_RST) 
 866   1          goto drop;
 867   1      
 868   1        UIP_STAT(++uip_stat.tcp.rst);
 869   1        
 870   1        BUF->flags = TCP_RST | TCP_ACK;
 871   1        uip_len = 40;
 872   1        BUF->tcpoffset = 5 << 4;
 873   1      
 874   1        /* Flip the seqno and ackno fields in the TCP header. */
 875   1        c = BUF->seqno[3];
 876   1        BUF->seqno[3] = BUF->ackno[3];  
 877   1        BUF->ackno[3] = c;
 878   1        
 879   1        c = BUF->seqno[2];
 880   1        BUF->seqno[2] = BUF->ackno[2];  
 881   1        BUF->ackno[2] = c;
 882   1        
 883   1        c = BUF->seqno[1];
 884   1        BUF->seqno[1] = BUF->ackno[1];
 885   1        BUF->ackno[1] = c;
 886   1        
 887   1        c = BUF->seqno[0];
 888   1        BUF->seqno[0] = BUF->ackno[0];  
 889   1        BUF->ackno[0] = c;
 890   1      
 891   1        /* We also have to increase the sequence number we are
 892   1           acknowledging. If the least significant byte overflowed, we need
 893   1           to propagate the carry to the other bytes as well. */
 894   1        if(++BUF->ackno[3] == 0) {
 895   2          if(++BUF->ackno[2] == 0) {
 896   3            if(++BUF->ackno[1] == 0) {
 897   4              ++BUF->ackno[0];
 898   4            }
 899   3          }
 900   2        }
 901   1       
 902   1        /* Swap port numbers. */
 903   1        tmp16 = BUF->srcport;
 904   1        BUF->srcport = BUF->destport;
 905   1        BUF->destport = tmp16;
 906   1        
 907   1        /* Swap IP addresses. */
 908   1        tmp16 = BUF->destipaddr[0];
 909   1        BUF->destipaddr[0] = BUF->srcipaddr[0];
 910   1        BUF->srcipaddr[0] = tmp16;
 911   1        tmp16 = BUF->destipaddr[1];
 912   1        BUF->destipaddr[1] = BUF->srcipaddr[1];
 913   1        BUF->srcipaddr[1] = tmp16;
 914   1      
 915   1        
 916   1        /* And send out the RST packet! */
 917   1        goto tcp_send_noconn;
 918   1      
 919   1        /* This label will be jumped to if we matched the incoming packet
 920   1           with a connection in LISTEN. In that case, we should create a new
 921   1           connection and send a SYNACK in return. */
 922   1       found_listen:
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 16  

 923   1        /* First we check if there are any connections avaliable. Unused
 924   1           connections are kept in the same table as used connections, but
 925   1           unused ones have the tcpstate set to CLOSED. Also, connections in
 926   1           TIME_WAIT are kept track of and we'll use the oldest one if no
 927   1           CLOSED connections are found. Thanks to Eddie C. Dost for a very
 928   1           nice algorithm for the TIME_WAIT search. */
 929   1        uip_connr = -1;    // 8051 xdata starts at 0x0000
 930   1        for(c = 0; c < UIP_CONNS; ++c) {
 931   2          if(uip_conns[c].tcpstateflags == CLOSED) {
 932   3            uip_connr = &uip_conns[c];
 933   3            break;
 934   3          }
 935   2          if(uip_conns[c].tcpstateflags == TIME_WAIT) {
 936   3            if(uip_connr == 0 ||
 937   3               uip_conns[c].timer > uip_connr->timer) {
 938   4              uip_connr = &uip_conns[c];
 939   4            }
 940   3          }
 941   2        }
 942   1      
 943   1        if(uip_connr == -1) {  // 8051 xdata starts at 0x0000
 944   2          /* All connections are used already, we drop packet and hope that
 945   2             the remote end will retransmit the packet at a time when we
 946   2             have more spare connections. */
 947   2          UIP_STAT(++uip_stat.tcp.syndrop);
 948   2          UIP_LOG("tcp: found no unused connections.");
 949   2          goto drop;
 950   2        }
 951   1        uip_conn = uip_connr;
*** WARNING C259 IN LINE 951 OF UIP\UIP.C: '=': pointer: different mspace
 952   1        
 953   1        /* Fill in the necessary fields for the new connection. */
 954   1        uip_connr->rto = uip_connr->timer = UIP_RTO;
 955   1        uip_connr->sa = 0;
 956   1        uip_connr->sv = 4;  
 957   1        uip_connr->nrtx = 0;
 958   1        uip_connr->lport = BUF->destport;
 959   1        uip_connr->rport = BUF->srcport;
 960   1        uip_connr->ripaddr[0] = BUF->srcipaddr[0];
 961   1        uip_connr->ripaddr[1] = BUF->srcipaddr[1];
 962   1        uip_connr->tcpstateflags = SYN_RCVD;
 963   1      
 964   1        uip_connr->snd_nxt[0] = iss[0];
 965   1        uip_connr->snd_nxt[1] = iss[1];
 966   1        uip_connr->snd_nxt[2] = iss[2];
 967   1        uip_connr->snd_nxt[3] = iss[3];
 968   1        uip_connr->len = 1;
 969   1      
 970   1        /* rcv_nxt should be the seqno from the incoming packet + 1. */
 971   1        uip_connr->rcv_nxt[3] = BUF->seqno[3];
 972   1        uip_connr->rcv_nxt[2] = BUF->seqno[2];
 973   1        uip_connr->rcv_nxt[1] = BUF->seqno[1];
 974   1        uip_connr->rcv_nxt[0] = BUF->seqno[0];
 975   1        uip_add_rcv_nxt(1);
 976   1      
 977   1        /* Parse the TCP MSS option, if present. */
 978   1        if((BUF->tcpoffset & 0xf0) > 0x50) {
 979   2          for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
 980   3            opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
 981   3            if(opt == 0x00) {
 982   4              /* End of options. */   
 983   4              break;
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 17  

 984   4            } else if(opt == 0x01) {
 985   4              ++c;
 986   4              /* NOP option. */
 987   4            } else if(opt == 0x02 &&
 988   3                      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0x04) {
 989   4              /* An MSS option with the right option length. */       
 990   4              tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
 991   4                (u16_t)uip_buf[40 + UIP_LLH_LEN + 3 + c];
 992   4              uip_connr->initialmss = uip_connr->mss =
 993   4                tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
 994   4              
 995   4              /* And we are done processing options. */
 996   4              break;
 997   4            } else {
 998   4              /* All other options have a length field, so that we easily
 999   4                 can skip past them. */
1000   4              if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
1001   5                /* If the length field is zero, the options are malformed
1002   5                   and we don't process them further. */
1003   5                break;
1004   5              }
1005   4              c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
1006   4            }      
1007   3          }
1008   2        }
1009   1        
1010   1        /* Our response will be a SYNACK. */
1011   1      #if UIP_ACTIVE_OPEN
1012   1       tcp_send_synack:
1013   1        BUF->flags = TCP_ACK;    
1014   1        
1015   1       tcp_send_syn:
1016   1        BUF->flags |= TCP_SYN;    
1017   1      #else /* UIP_ACTIVE_OPEN */
               tcp_send_synack:
                BUF->flags = TCP_SYN | TCP_ACK;    
              #endif /* UIP_ACTIVE_OPEN */
1021   1        
1022   1        /* We send out the TCP Maximum Segment Size option with our
1023   1           SYNACK. */
1024   1        BUF->optdata[0] = 2;
1025   1        BUF->optdata[1] = 4;
1026   1        BUF->optdata[2] = (UIP_TCP_MSS) / 256;
1027   1        BUF->optdata[3] = (UIP_TCP_MSS) & 255;
1028   1        uip_len = 44;
1029   1        BUF->tcpoffset = 6 << 4;
1030   1        goto tcp_send;
1031   1      
1032   1        /* This label will be jumped to if we found an active connection. */
1033   1       found:
1034   1        uip_conn = uip_connr;
*** WARNING C259 IN LINE 1034 OF UIP\UIP.C: '=': pointer: different mspace
1035   1        uip_flags = 0;
1036   1      
1037   1        /* We do a very naive form of TCP reset processing; we just accept
1038   1           any RST and kill our connection. We should in fact check if the
1039   1           sequence number of this reset is wihtin our advertised window
1040   1           before we accept the reset. */
1041   1        if(BUF->flags & TCP_RST) {
1042   2          uip_connr->tcpstateflags = CLOSED;
1043   2          UIP_LOG("tcp: got reset, aborting connection.");
1044   2          uip_flags = UIP_ABORT;
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 18  

1045   2          UIP_APPCALL();
1046   2          goto drop;
1047   2        }      
1048   1        /* Calculated the length of the data, if the application has sent
1049   1           any data to us. */
1050   1        c = (BUF->tcpoffset >> 4) << 2;
1051   1        /* uip_len will contain the length of the actual TCP data. This is
1052   1           calculated by subtracing the length of the TCP header (in
1053   1           c) and the length of the IP header (20 bytes). */
1054   1        uip_len = uip_len - c - 20;
1055   1      
1056   1        /* First, check if the sequence number of the incoming packet is
1057   1           what we're expecting next. If not, we send out an ACK with the
1058   1           correct numbers in. */
1059   1        if(uip_len > 0 &&
1060   1           (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
1061   1            BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
1062   1            BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
1063   1            BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
1064   2          goto tcp_send_ack;
1065   2        }
1066   1      
1067   1        /* Next, check if the incoming segment acknowledges any outstanding
1068   1           data. If so, we update the sequence number, reset the length of
1069   1           the outstanding data, calculate RTT estimations, and reset the
1070   1           retransmission timer. */
1071   1        if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
1072   2          uip_add32(uip_connr->snd_nxt, uip_connr->len);
1073   2          if(BUF->ackno[0] == uip_acc32[0] &&
1074   2             BUF->ackno[1] == uip_acc32[1] &&
1075   2             BUF->ackno[2] == uip_acc32[2] &&
1076   2             BUF->ackno[3] == uip_acc32[3]) {
1077   3            /* Update sequence number. */
1078   3            uip_connr->snd_nxt[0] = uip_acc32[0];
1079   3            uip_connr->snd_nxt[1] = uip_acc32[1];
1080   3            uip_connr->snd_nxt[2] = uip_acc32[2];
1081   3            uip_connr->snd_nxt[3] = uip_acc32[3];
1082   3              
1083   3      
1084   3            /* Do RTT estimation, unless we have done retransmissions. */
1085   3            if(uip_connr->nrtx == 0) {
1086   4              signed char m;
1087   4              m = uip_connr->rto - uip_connr->timer;
1088   4              /* This is taken directly from VJs original code in his paper */
1089   4              m = m - (uip_connr->sa >> 3);
1090   4              uip_connr->sa += m;
1091   4              if(m < 0) {
1092   5                m = -m;
1093   5              }
1094   4              m = m - (uip_connr->sv >> 2);
1095   4              uip_connr->sv += m;
1096   4              uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
1097   4      
1098   4            }
1099   3            /* Set the acknowledged flag. */
1100   3            uip_flags = UIP_ACKDATA;
1101   3            /* Reset the retransmission timer. */
1102   3            uip_connr->timer = uip_connr->rto;
1103   3          }
1104   2          
1105   2        }
1106   1      
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 19  

1107   1        /* Do different things depending on in what state the connection is. */
1108   1        switch(uip_connr->tcpstateflags & TS_MASK) {
1109   2          /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
1110   2              implemented, since we force the application to close when the
1111   2              peer sends a FIN (hence the application goes directly from
1112   2              ESTABLISHED to LAST_ACK). */
1113   2        case SYN_RCVD:
1114   2          /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
1115   2             we are waiting for an ACK that acknowledges the data we sent
1116   2             out the last time. Therefore, we want to have the UIP_ACKDATA
1117   2             flag set. If so, we enter the ESTABLISHED state. */
1118   2          if(uip_flags & UIP_ACKDATA) {
1119   3            uip_connr->tcpstateflags = ESTABLISHED;
1120   3            uip_flags = UIP_CONNECTED;
1121   3            uip_connr->len = 0;
1122   3            if(uip_len > 0) {
1123   4              uip_flags |= UIP_NEWDATA;
1124   4              uip_add_rcv_nxt(uip_len);
1125   4            }
1126   3            uip_slen = 0;
1127   3            UIP_APPCALL();
1128   3            goto appsend;
1129   3          }
1130   2          goto drop;
1131   2      #if UIP_ACTIVE_OPEN
1132   2        case SYN_SENT:
1133   2          /* In SYN_SENT, we wait for a SYNACK that is sent in response to
1134   2             our SYN. The rcv_nxt is set to sequence number in the SYNACK
1135   2             plus one, and we send an ACK. We move into the ESTABLISHED
1136   2             state. */
1137   2          if((uip_flags & UIP_ACKDATA) &&
1138   2             BUF->flags == (TCP_SYN | TCP_ACK)) {
1139   3      
1140   3            /* Parse the TCP MSS option, if present. */
1141   3            if((BUF->tcpoffset & 0xf0) > 0x50) {
1142   4              for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
1143   5                opt = uip_buf[40 + UIP_LLH_LEN + c];
1144   5                if(opt == 0x00) {
1145   6                  /* End of options. */       
1146   6                  break;
1147   6                } else if(opt == 0x01) {
1148   6                  ++c;
1149   6                  /* NOP option. */
1150   6                } else if(opt == 0x02 &&
1151   5                          uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0x04) {
1152   6                  /* An MSS option with the right option length. */
1153   6                  tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
1154   6                    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
1155   6                  uip_connr->initialmss =
1156   6                    uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
1157   6      
1158   6                  /* And we are done processing options. */
1159   6                  break;
1160   6                } else {
1161   6                  /* All other options have a length field, so that we easily
1162   6                     can skip past them. */
1163   6                  if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
1164   7                    /* If the length field is zero, the options are malformed
1165   7                       and we don't process them further. */
1166   7                    break;
1167   7                  }
1168   6                  c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 20  

1169   6                }      
1170   5              }
1171   4            }
1172   3            uip_connr->tcpstateflags = ESTABLISHED;      
1173   3            uip_connr->rcv_nxt[0] = BUF->seqno[0];
1174   3            uip_connr->rcv_nxt[1] = BUF->seqno[1];
1175   3            uip_connr->rcv_nxt[2] = BUF->seqno[2];
1176   3            uip_connr->rcv_nxt[3] = BUF->seqno[3];
1177   3            uip_add_rcv_nxt(1);
1178   3            uip_flags = UIP_CONNECTED | UIP_NEWDATA;
1179   3            uip_connr->len = 0;
1180   3            uip_len = 0;
1181   3            uip_slen = 0;
1182   3            UIP_APPCALL();
1183   3            goto appsend;
1184   3          }
1185   2          goto reset;
1186   2      #endif /* UIP_ACTIVE_OPEN */
1187   2          
1188   2        case ESTABLISHED:
1189   2          /* In the ESTABLISHED state, we call upon the application to feed
1190   2          data into the uip_buf. If the UIP_ACKDATA flag is set, the
1191   2          application should put new data into the buffer, otherwise we are
1192   2          retransmitting an old segment, and the application should put that
1193   2          data into the buffer.
1194   2      
1195   2          If the incoming packet is a FIN, we should close the connection on
1196   2          this side as well, and we send out a FIN and enter the LAST_ACK
1197   2          state. We require that there is no outstanding data; otherwise the
1198   2          sequence numbers will be screwed up. */
1199   2      
1200   2          if(BUF->flags & TCP_FIN) {
1201   3            if(uip_outstanding(uip_connr)) {
1202   4              goto drop;
1203   4            }
1204   3            uip_add_rcv_nxt(1 + uip_len);      
1205   3            uip_flags = UIP_CLOSE;
1206   3            if(uip_len > 0) {
1207   4              uip_flags |= UIP_NEWDATA;
1208   4            }
1209   3            UIP_APPCALL();
1210   3            uip_connr->len = 1;
1211   3            uip_connr->tcpstateflags = LAST_ACK;
1212   3            uip_connr->nrtx = 0;
1213   3          tcp_send_finack:
1214   3            BUF->flags = TCP_FIN | TCP_ACK;      
1215   3            goto tcp_send_nodata;
1216   3          }
1217   2      
1218   2          /* Check the URG flag. If this is set, the segment carries urgent
1219   2             data that we must pass to the application. */
1220   2          if(BUF->flags & TCP_URG) {
1221   3      #if UIP_URGDATA > 0
1222   3            uip_urglen = (BUF->urgp[0] << 8) | BUF->urgp[1];
1223   3            if(uip_urglen > uip_len) {
1224   4              /* There is more urgent data in the next segment to come. */
1225   4              uip_urglen = uip_len;
1226   4            }
1227   3            uip_add_rcv_nxt(uip_urglen);
1228   3            uip_len -= uip_urglen;
1229   3            uip_urgdata = uip_appdata;
1230   3            uip_appdata += uip_urglen;
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 21  

1231   3          } else {
1232   3            uip_urglen = 0;
1233   3      #endif /* UIP_URGDATA > 0 */
1234   3            uip_appdata += (BUF->urgp[0] << 8) | BUF->urgp[1];
1235   3            uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
1236   3          }
1237   2          
1238   2          
1239   2          /* If uip_len > 0 we have TCP data in the packet, and we flag this
1240   2             by setting the UIP_NEWDATA flag and update the sequence number
1241   2             we acknowledge. If the application has stopped the dataflow
1242   2             using uip_stop(), we must not accept any data packets from the
1243   2             remote host. */
1244   2          if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
1245   3            uip_flags |= UIP_NEWDATA;
1246   3            uip_add_rcv_nxt(uip_len);
1247   3          }
1248   2      
1249   2          /* Check if the available buffer space advertised by the other end
1250   2             is smaller than the initial MSS for this connection. If so, we
1251   2             set the current MSS to the window size to ensure that the
1252   2             application does not send more data than the other end can
1253   2             handle.
1254   2      
1255   2             If the remote host advertises a zero window, we set the MSS to
1256   2             the initial MSS so that the application will send an entire MSS
1257   2             of data. This data will not be acknowledged by the receiver,
1258   2             and the application will retransmit it. This is called the
1259   2             "persistent timer" and uses the retransmission mechanim.
1260   2          */
1261   2          tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
1262   2          if(tmp16 > uip_connr->initialmss ||
1263   2             tmp16 == 0) {
1264   3            tmp16 = uip_connr->initialmss;
1265   3          }
1266   2          uip_connr->mss = tmp16;
1267   2      
1268   2          /* If this packet constitutes an ACK for outstanding data (flagged
1269   2             by the UIP_ACKDATA flag, we should call the application since it
1270   2             might want to send more data. If the incoming packet had data
1271   2             from the peer (as flagged by the UIP_NEWDATA flag), the
1272   2             application must also be notified.
1273   2      
1274   2             When the application is called, the global variable uip_len
1275   2             contains the length of the incoming data. The application can
1276   2             access the incoming data through the global pointer
1277   2             uip_appdata, which usually points 40 bytes into the uip_buf
1278   2             array.
1279   2      
1280   2             If the application wishes to send any data, this data should be
1281   2             put into the uip_appdata and the length of the data should be
1282   2             put into uip_len. If the application don't have any data to
1283   2             send, uip_len must be set to 0. */
1284   2          if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
1285   3            uip_slen = 0;
1286   3            UIP_APPCALL(); 
1287   3      
1288   3          appsend:
1289   3            
1290   3            if(uip_flags & UIP_ABORT) {
1291   4              uip_slen = 0;
1292   4              uip_connr->tcpstateflags = CLOSED;
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 22  

1293   4              BUF->flags = TCP_RST | TCP_ACK;
1294   4              goto tcp_send_nodata;
1295   4            }
1296   3      
1297   3            if(uip_flags & UIP_CLOSE) {
1298   4              uip_slen = 0;
1299   4              uip_connr->len = 1;
1300   4              uip_connr->tcpstateflags = FIN_WAIT_1;
1301   4              uip_connr->nrtx = 0;
1302   4              BUF->flags = TCP_FIN | TCP_ACK;
1303   4              goto tcp_send_nodata;   
1304   4            }
1305   3      
1306   3            /* If uip_slen > 0, the application has data to be sent. */
1307   3            if(uip_slen > 0) {
1308   4      
1309   4              /* If the connection has acknowledged data, the contents of
1310   4                 the ->len variable should be discarded. */ 
1311   4              if((uip_flags & UIP_ACKDATA) != 0) {
1312   5                uip_connr->len = 0;
1313   5              }
1314   4      
1315   4              /* If the ->len variable is non-zero the connection has
1316   4                 already data in transit and cannot send anymore right
1317   4                 now. */
1318   4              if(uip_connr->len == 0) {
1319   5      
1320   5                /* The application cannot send more than what is allowed by
1321   5                   the mss (the minumum of the MSS and the available
1322   5                   window). */
1323   5                if(uip_slen > uip_connr->mss) {
1324   6                  uip_slen = uip_connr->mss;
1325   6                }
1326   5      
1327   5                /* Remember how much data we send out now so that we know
1328   5                   when everything has been acknowledged. */
1329   5                uip_connr->len = uip_slen;
1330   5              } else {
1331   5      
1332   5                /* If the application already had unacknowledged data, we
1333   5                   make sure that the application does not send (i.e.,
1334   5                   retransmit) out more than it previously sent out. */
1335   5                uip_slen = uip_connr->len;
1336   5              }
1337   4            } else {
1338   4              uip_connr->len = 0;
1339   4            }
1340   3            uip_connr->nrtx = 0;
1341   3          apprexmit:
1342   3            uip_appdata = uip_sappdata;
1343   3            
1344   3            /* If the application has data to be sent, or if the incoming
1345   3               packet had new data in it, we must send out a packet. */
1346   3            if(uip_slen > 0 && uip_connr->len > 0) {
1347   4              /* Add the length of the IP and TCP headers. */
1348   4              uip_len = uip_connr->len + UIP_TCPIP_HLEN;
1349   4              /* We always set the ACK flag in response packets. */
1350   4              BUF->flags = TCP_ACK | TCP_PSH;
1351   4              /* Send the packet. */
1352   4              goto tcp_send_noopts;
1353   4            }
1354   3            /* If there is no data to send, just send out a pure ACK if
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 23  

1355   3               there is newdata. */
1356   3            if(uip_flags & UIP_NEWDATA) {
1357   4              uip_len = UIP_TCPIP_HLEN;
1358   4              BUF->flags = TCP_ACK;
1359   4              goto tcp_send_noopts;
1360   4            }
1361   3          }
1362   2          goto drop;
1363   2        case LAST_ACK:
1364   2          /* We can close this connection if the peer has acknowledged our
1365   2             FIN. This is indicated by the UIP_ACKDATA flag. */     
1366   2          if(uip_flags & UIP_ACKDATA) {
1367   3            uip_connr->tcpstateflags = CLOSED;
1368   3            uip_flags = UIP_CLOSE;
1369   3            UIP_APPCALL();
1370   3          }
1371   2          break;
1372   2          
1373   2        case FIN_WAIT_1:
1374   2          /* The application has closed the connection, but the remote host
1375   2             hasn't closed its end yet. Thus we do nothing but wait for a
1376   2             FIN from the other side. */
1377   2          if(uip_len > 0) {
1378   3            uip_add_rcv_nxt(uip_len);
1379   3          }
1380   2          if(BUF->flags & TCP_FIN) {
1381   3            if(uip_flags & UIP_ACKDATA) {
1382   4              uip_connr->tcpstateflags = TIME_WAIT;
1383   4              uip_connr->timer = 0;
1384   4              uip_connr->len = 0;
1385   4            } else {
1386   4              uip_connr->tcpstateflags = CLOSING;
1387   4            }
1388   3            uip_add_rcv_nxt(1);
1389   3            uip_flags = UIP_CLOSE;
1390   3      
1391   3            UIP_APPCALL(); 
1392   3            goto tcp_send_ack;
1393   3          } else if(uip_flags & UIP_ACKDATA) {
1394   3            uip_connr->tcpstateflags = FIN_WAIT_2;
1395   3            uip_connr->len = 0;
1396   3            goto drop;
1397   3          }
1398   2          if(uip_len > 0) {
1399   3            goto tcp_send_ack;
1400   3          }
1401   2          goto drop;
1402   2            
1403   2        case FIN_WAIT_2:
1404   2          if(uip_len > 0) {
1405   3            uip_add_rcv_nxt(uip_len);
1406   3          }
1407   2          if(BUF->flags & TCP_FIN) {
1408   3            uip_connr->tcpstateflags = TIME_WAIT;
1409   3            uip_connr->timer = 0;
1410   3            uip_add_rcv_nxt(1);
1411   3            uip_flags = UIP_CLOSE;
1412   3            UIP_APPCALL();
1413   3            goto tcp_send_ack;
1414   3          }
1415   2          if(uip_len > 0) {
1416   3            goto tcp_send_ack;
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 24  

1417   3          }
1418   2          goto drop;
1419   2      
1420   2        case TIME_WAIT:
1421   2          goto tcp_send_ack;
1422   2          
1423   2        case CLOSING:
1424   2          if(uip_flags & UIP_ACKDATA) {
1425   3            uip_connr->tcpstateflags = TIME_WAIT;
1426   3            uip_connr->timer = 0;
1427   3          }
1428   2        }  
1429   1        goto drop;
1430   1        
1431   1      
1432   1        /* We jump here when we are ready to send the packet, and just want
1433   1           to set the appropriate TCP sequence numbers in the TCP header. */
1434   1       tcp_send_ack:
1435   1        BUF->flags = TCP_ACK;
1436   1       tcp_send_nodata:
1437   1        uip_len = 40;
1438   1       tcp_send_noopts:
1439   1        BUF->tcpoffset = 5 << 4;
1440   1       tcp_send:
1441   1        /* We're done with the input processing. We are now ready to send a
1442   1           reply. Our job is to fill in all the fields of the TCP and IP
1443   1           headers before calculating the checksum and finally send the
1444   1           packet. */
1445   1        BUF->ackno[0] = uip_connr->rcv_nxt[0];
1446   1        BUF->ackno[1] = uip_connr->rcv_nxt[1];
1447   1        BUF->ackno[2] = uip_connr->rcv_nxt[2];
1448   1        BUF->ackno[3] = uip_connr->rcv_nxt[3];
1449   1        
1450   1        BUF->seqno[0] = uip_connr->snd_nxt[0];
1451   1        BUF->seqno[1] = uip_connr->snd_nxt[1];
1452   1        BUF->seqno[2] = uip_connr->snd_nxt[2];
1453   1        BUF->seqno[3] = uip_connr->snd_nxt[3];
1454   1      
1455   1        BUF->proto = UIP_PROTO_TCP;
1456   1        
1457   1        BUF->srcport  = uip_connr->lport;
1458   1        BUF->destport = uip_connr->rport;
1459   1      
1460   1        BUF->srcipaddr[0] = uip_hostaddr[0];
1461   1        BUF->srcipaddr[1] = uip_hostaddr[1];
1462   1        BUF->destipaddr[0] = uip_connr->ripaddr[0];
1463   1        BUF->destipaddr[1] = uip_connr->ripaddr[1];
1464   1       
1465   1      
1466   1        if(uip_connr->tcpstateflags & UIP_STOPPED) {
1467   2          /* If the connection has issued uip_stop(), we advertise a zero
1468   2             window so that the remote host will stop sending data. */
1469   2          BUF->wnd[0] = BUF->wnd[1] = 0;
1470   2        } else {
1471   2          BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
1472   2          BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff); 
1473   2        }
1474   1      
1475   1       tcp_send_noconn:
1476   1      
1477   1        BUF->len[0] = (uip_len >> 8);
1478   1        BUF->len[1] = (uip_len & 0xff);
C51 COMPILER V9.01   UIP                                                                   08/23/2013 20:12:41 PAGE 25  

1479   1      
1480   1        /* Calculate TCP checksum. */
1481   1        BUF->tcpchksum = 0;
1482   1        BUF->tcpchksum = ~(uip_tcpchksum());
1483   1        
1484   1      ip_send_nolen:
1485   1      
1486   1        BUF->vhl = 0x45;
1487   1        BUF->tos = 0;
1488   1        BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
1489   1        BUF->ttl  = UIP_TTL;
1490   1        ++ipid;
1491   1        BUF->ipid[0] = ipid >> 8;
1492   1        BUF->ipid[1] = ipid & 0xff;
1493   1        
1494   1        /* Calculate IP checksum. */
1495   1        BUF->ipchksum = 0;
1496   1        BUF->ipchksum = ~(uip_ipchksum());
1497   1      
1498   1        UIP_STAT(++uip_stat.tcp.sent);
1499   1       send:
1500   1        UIP_STAT(++uip_stat.ip.sent);
1501   1        /* Return and let the caller do the actual transmission. */
1502   1        return;
1503   1       drop:
1504   1        uip_len = 0;
1505   1        return;
1506   1      }
*** WARNING C280 IN LINE 705 OF UIP\UIP.C: 'icmp_input': unreferenced label
*** WARNING C280 IN LINE 1484 OF UIP\UIP.C: 'ip_send_nolen': unreferenced label
1507          /*-----------------------------------------------------------------------------------*/
1508          u16_t
1509          htons(u16_t val)
1510          {
1511   1        return HTONS(val);
1512   1      }
1513          /*-----------------------------------------------------------------------------------*/
1514          /** @} */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4535    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   1670    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15      15
   IDATA SIZE       =     31    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
